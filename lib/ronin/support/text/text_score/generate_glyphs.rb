# frozen_string_literal: true
require 'awesome_print'
require 'erb'

# Computes n-glyphs from a corpus of text
class NGlyphFrequencyAnalyzer
  attr_reader :n
  attr_accessor :scores

  GLYPH_SORT_INDEX = 0
  SCORE_SORT_INDEX = 1

  # @params the N value to compute with
  def initialize(n)
    @n      = n
    @data   = ""
    @scores = Hash.new(0)
  end

  def add_corpus(text)
    @data += text
  end

  def to_blocks
    @data.chars.map.with_index { |_, i| @data[i, @n] }
  end

  def score
    # get all unique blocks of size n (the n-glyphs)
    blocks = self.to_blocks.uniq.drop(@n)
    # scan the data for each glyph
    blocks.each do |block|
      next if block.match(/\W/) # ignore spaces

      @scores[block] += @data.scan(Regexp.escape(block)).count
    rescue ArgumentError
      puts "could not count on #{block} for some reason"
      break
    end

    all_score_sum = @scores.values.sum
    puts "score sum: #{all_score_sum}"

    @scores.each_key { |k|
      @scores[k] = ( @scores[k].to_r / all_score_sum.to_r ).to_f
    }

    all_score_sum = @scores.values.sum
    puts "score sum after normalization: #{all_score_sum}"
    self
  end

  def top
    # sort hash into [[<glyph>, <score>], ...]
    scores      = @scores.sort_by { |k, v| v }.reverse.to_h
    # compute 1% of the normal frequency of the highest frequency glyph
    one_percent = scores.values[0] * 0.01
    # delete any elements with scores lower than 1%
    scores.delete_if { |k, v| v < one_percent }
  end

end

def main
  test_data_path = "./test_data"
  analyzers      = [
    NGlyphFrequencyAnalyzer.new(1),
    NGlyphFrequencyAnalyzer.new(2),
    NGlyphFrequencyAnalyzer.new(3)
  ]
  prefixes       = [
    nil, "MONO", "DI", "TRI"
  ]

  data_dir = Dir.children(test_data_path)
  data_dir.each do |fname|
    analyzers.each do |analyzer|
      analyzer.add_corpus File.read("#{test_data_path}/#{fname}")
    end
  end

  template        = <<~TEMPLATE_EOF
    ##########################################################
    # NOTICE: this script is generated by generate_glyphs.rb #
    ##########################################################

    module Ronin
      module Support
        module Text
          # Negitive constant to make random data look even less like english
          # -phi because I was just working on fib calculators
          NOISE_CONSTANT = -1.618
        <% analyzers.each do | analyzer | %>
          ##{' '}
          # a <%=prefixes[analyzer.n]%>glyph is a section of text that is <%= analyzer.n %> characters long appering in text.#{' '}
          # These glyphs have english text scores which can be summed to score text based on language
          #
          <%=prefixes[analyzer.n]%>GLYPH_MAP = <%= analyzer.score.top %>
        <% end %>
        end
      end
    end
  TEMPLATE_EOF

  glyph_defs = ERB.new template
  if ARGV.empty?
    print glyph_defs.result(binding)
  else
    File.write(ARGV[0], glyph_defs.result(binding))
  end
end

main
